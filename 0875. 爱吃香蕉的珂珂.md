## 题目

珂珂喜欢吃香蕉。这里有 N 堆香蕉，第 i 堆中有 piles[i] 根香蕉。警卫已经离开了，将在 H 小时后回来。

珂珂可以决定她吃香蕉的速度 K （单位：根/小时）。每个小时，她将会选择一堆香蕉，从中吃掉 K 根。如果这堆香蕉少于 K 根，她将吃掉这堆的所有香蕉，然后这一小时内不会再吃更多的香蕉。  

珂珂喜欢慢慢吃，但仍然想在警卫回来前吃掉所有的香蕉。

返回她可以在 H 小时内吃掉所有香蕉的最小速度 K（K 为整数）。

#### 示例1

```
输入: piles = [3,6,7,11], H = 8
输出: 4
```

#### 示例2

```
输入: piles = [30,11,23,4,20], H = 5
输出: 30
```

#### 示例3

```
输入: piles = [30,11,23,4,20], H = 6
输出: 23
```

## 思路

有一类问题是这样的：目标变量和另一个变量有相关关系（一般而言是线性关系），目标变量的性质不好推测，但是另一个变量的性质相对容易推测。这样的问题的判别函数通常会写成一个函数的形式。

回到本题，最小速度 K 是一个整数，并且我们知道这个 K 不可能无限大，珂珂一个小时能吃的香蕉最多为一整堆香蕉的个数。因此 K 是一个有范围的整数。如果我们做多了二分查找的问题，就知道这样的问题可以考虑使用二分查找去做，事实上，这道问题的解题思路就是「二分答案」。

根据题意，我们不难分析出，如果珂珂每个小时吃的香蕉数越少，那么她吃完所有香蕉的耗时就越多；相应地，如果珂珂每个小时吃的香蕉数越多，那么她吃完所有香蕉的耗时就越少。

题目要我们找的最小速度，而限制是 H （吃完香蕉的所有时间）。因此我们就可以根据「吃完香蕉的所有时间」的限制，通过二分搜索的办法，得到最小的速度。

查找的是最小速度。由于题目限制了珂珂一个小时之内只能选择一堆香蕉吃，因此速度最大值就是这几堆香蕉中，数量最多的那一堆。速度的最小值是 11，还是因为珂珂一个小时之内只能选择一堆香蕉吃，因此：「`每堆香蕉吃完的耗时 = 这堆香蕉的数量 / 珂珂一小时吃香蕉的数量`」。根据题意，这里的` / `在不能整除的时候，需要 上取整。

先根据珂珂每小时吃掉的香蕉数，计算吃完所有香蕉的耗时，再根据下面的逻辑逼近到最小速度 a ：

* 如果耗时大于 H ，则说明速度太慢了，下一轮搜索的时候需要从 a + 1 开始；
* 如果耗时小于等于 H ，则说明速度或者刚好合适，或者太慢了，下一轮搜索的时候速度至多是 a （这里不能把速度 a 的值排除掉）。

```java
class Solution {
    public int minEatingSpeed(int[] piles, int h) {
        int maxval = 1;
        for (int pile = 0; pile < piles.length; pile++) {
            maxval = Math.max(maxval, piles[pile]);
        }
         int left = 1;
         int right = maxval;
         while(left < right) {
             int speed = left + (right - left) / 2;
             if(calculatSpeed(piles, speed) > h) {
                 left = speed + 1;
             } else {
                 right = speed;
             }
        }
         return right;
    }
    public int calculatSpeed(int[] piles, int speed) {
        int sum = 0;
        for (int pile = 0; pile < piles.length; pile++) {
            sum += (piles[pile] + speed - 1) / speed;// 上取整
        }
        return sum;
    }
}
```

